// Third-Party Library Headers
#include <gtest/gtest.h>
#include <thread>
#include <chrono>
#include <future>
#include <atomic>

// Project-Specific Headers
#include "TestFixtures.h"
#include "TestMocks.h"
#include "ConfigSingleton.h"
#include "DatabaseManager.h"
#include "fileProcessor.h"
#include "transcriptionProcessor.h"
#include "fasterWhisper.h"

// =============================================================================
// END-TO-END INTEGRATION TESTS
// =============================================================================

class EndToEndIntegrationTest : public SDRTrunkTestFixture {
protected:
    std::unique_ptr<DatabaseManager> dbManager;
    std::string integrationTestDir;
    
    void SetUp() override {
        SDRTrunkTestFixture::SetUp();
        dbManager = std::make_unique<DatabaseManager>(":memory:");
        dbManager->createTable();
        integrationTestDir = fileManager->createTempDirectory("integration_test");
    }
};

TEST_F(EndToEndIntegrationTest, CompleteWorkflowTest) {    // Step 1: Initialize configuration\n    YAML::Node config = loadTestConfig();\n    auto& configSingleton = ConfigSingleton::getInstance();\n    configSingleton.initialize(config);\n    \n    EXPECT_EQ(configSingleton.getOpenAIAPIKey(), "test-api-key-12345");\n    EXPECT_EQ(configSingleton.getDatabasePath(), ":memory:");\n    \n    // Step 2: Create test audio file with realistic filename\n    std::string testFilename = TestDataGenerator::generateP25Filename(\n        2024, 1, 15, 14, 30, 45, 52198, 12345\n    );\n    std::string testFilePath = integrationTestDir + "/" + testFilename;\n    auto audioData = TestDataGenerator::generateMockMP3Data();\n    std::ofstream audioFile(testFilePath, std::ios::binary);\n    audioFile.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n    audioFile.close();\n    \n    // Step 3: Process the file\n    FileData processedData = processFile(\n        std::filesystem::path(testFilePath), \n        integrationTestDir, \n        configSingleton.getOpenAIAPIKey()\n    );\n    \n    // Verify file processing results\n    EXPECT_EQ(processedData.talkgroupID, 52198);\n    EXPECT_EQ(processedData.radioID, 12345);\n    EXPECT_EQ(processedData.date, "2024-01-15");\n    EXPECT_EQ(processedData.time, "14:30:45");\n    EXPECT_FALSE(processedData.filename.empty());\n    \n    // Step 4: Generate V2 transcription with glossary\n    const auto& talkgroupFiles = configSingleton.getTalkgroupFiles();\n    std::string mockTranscription = TestDataGenerator::generateOpenAIResponse(\n        "Unit officer responding to 10-4 at Main Street"\n    );\n    \n    std::string v2Transcription = generateV2Transcription(\n        mockTranscription, processedData.talkgroupID, processedData.radioID, talkgroupFiles\n    );\n    \n    EXPECT_FALSE(v2Transcription.empty());\n    EXPECT_NE(v2Transcription.find("police officer"), std::string::npos);\n    EXPECT_NE(v2Transcription.find("acknowledged"), std::string::npos);\n    \n    // Step 5: Store in database\n    processedData.transcription = extractActualTranscription(mockTranscription);\n    processedData.v2transcription = v2Transcription;\n    \n    EXPECT_NO_THROW(dbManager->insertRecording(\n        processedData.date, processedData.time, processedData.unixtime,\n        processedData.talkgroupID, processedData.talkgroupName, processedData.radioID,\n        processedData.duration, processedData.filename, processedData.filepath,\n        processedData.transcription, processedData.v2transcription\n    ));\n}\n\nTEST_F(EndToEndIntegrationTest, MultipleFileProcessingWorkflow) {\n    // Initialize configuration\n    YAML::Node config = loadTestConfig();\n    auto& configSingleton = ConfigSingleton::getInstance();\n    configSingleton.initialize(config);\n    \n    // Create multiple test files with different talkgroups\n    std::vector<std::tuple<int, int, std::string>> testCases = {\n        {52198, 12345, "Unit officer responding to call"},\n        {52199, 12346, "Backup unit en route to location"},\n        {52200, 12347, "10-4 acknowledged, clear"},\n        {99999, 99999, "Default talkgroup transmission"}  // Should use default glossary\n    };\n    \n    std::vector<FileData> processedFiles;\n    \n    for (const auto& [talkgroupID, radioID, transcriptText] : testCases) {\n        // Create test file\n        std::string filename = TestDataGenerator::generateP25Filename(\n            2024, 1, 15, 14, 30, 45, talkgroupID, radioID\n        );\n        std::string filePath = integrationTestDir + "/" + filename;\n        auto audioData = TestDataGenerator::generateMockMP3Data();\n        std::ofstream file(filePath, std::ios::binary);\n        file.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n        file.close();\n        \n        // Process file\n        FileData data = processFile(\n            std::filesystem::path(filePath),\n            integrationTestDir,\n            configSingleton.getOpenAIAPIKey()\n        );\n        \n        // Generate V2 transcription\n        std::string mockTranscription = TestDataGenerator::generateOpenAIResponse(transcriptText);\n        data.transcription = extractActualTranscription(mockTranscription);\n        data.v2transcription = generateV2Transcription(\n            mockTranscription, data.talkgroupID, data.radioID, \n            configSingleton.getTalkgroupFiles()\n        );\n        \n        processedFiles.push_back(data);\n        \n        // Store in database\n        EXPECT_NO_THROW(dbManager->insertRecording(\n            data.date, data.time, data.unixtime, data.talkgroupID,\n            data.talkgroupName, data.radioID, data.duration,\n            data.filename, data.filepath, data.transcription, data.v2transcription\n        ));\n    }\n    \n    // Verify all files were processed correctly\n    EXPECT_EQ(processedFiles.size(), 4);\n    \n    // Check that NCSHP files got enhanced glossary mappings\n    for (const auto& data : processedFiles) {\n        if (data.talkgroupID >= 52198 && data.talkgroupID <= 52250) {\n            EXPECT_NE(data.v2transcription.find("police officer"), std::string::npos)\n                << "NCSHP file should have enhanced glossary: " << data.filename;\n        }\n    }\n}\n\n// =============================================================================\n// CONFIGURATION VALIDATION INTEGRATION TESTS\n// =============================================================================\n\nclass ConfigValidationIntegrationTest : public SDRTrunkTestFixture {};\n\nTEST_F(ConfigValidationIntegrationTest, InvalidConfigurationHandling) {\n    // Test with missing required fields\n    YAML::Node invalidConfig;\n    invalidConfig["DATABASE_PATH"] = ":memory:";\n    // Missing OPENAI_API_KEY\n    \n    auto& configSingleton = ConfigSingleton::getInstance();\n    \n    // Should handle missing configuration gracefully\n    EXPECT_THROW(configSingleton.initialize(invalidConfig), std::exception);\n}\n\nTEST_F(ConfigValidationIntegrationTest, TalkgroupFilesConfigurationValidation) {\n    YAML::Node config = loadTestConfig();\n    auto& configSingleton = ConfigSingleton::getInstance();\n    configSingleton.initialize(config);\n    \n    const auto& talkgroupFiles = configSingleton.getTalkgroupFiles();\n    \n    // Verify talkgroup range mapping\n    EXPECT_TRUE(talkgroupFiles.find(52198) != talkgroupFiles.end());\n    EXPECT_TRUE(talkgroupFiles.find(52225) != talkgroupFiles.end());\n    EXPECT_TRUE(talkgroupFiles.find(52250) != talkgroupFiles.end());\n    \n    // Verify glossary files are accessible\n    for (const auto& [talkgroupID, files] : talkgroupFiles) {\n        for (const auto& glossaryFile : files.glossaryFiles) {\n            EXPECT_TRUE(std::filesystem::exists(glossaryFile))\n                << "Glossary file should exist: " << glossaryFile;\n        }\n    }\n}\n\nTEST_F(ConfigValidationIntegrationTest, DebugFlagsIntegration) {\n    YAML::Node config = loadTestConfig();\n    \n    // Enable debug flags\n    config["DEBUG_CURL_HELPER"] = true;\n    config["DEBUG_DATABASE_MANAGER"] = true;\n    config["DEBUG_FILE_PROCESSOR"] = true;\n    \n    auto& configSingleton = ConfigSingleton::getInstance();\n    configSingleton.initialize(config);\n    \n    EXPECT_TRUE(configSingleton.isDebugCurlHelper());\n    EXPECT_TRUE(configSingleton.isDebugDatabaseManager());\n    EXPECT_TRUE(configSingleton.isDebugFileProcessor());\n    EXPECT_FALSE(configSingleton.isDebugMain());  // Should remain false\n}\n\n// =============================================================================\n// DATABASE MIGRATION AND SCHEMA TESTS\n// =============================================================================\n\nclass DatabaseMigrationTest : public SDRTrunkTestFixture {\nprotected:\n    std::string persistentDbPath;\n    \n    void SetUp() override {\n        SDRTrunkTestFixture::SetUp();\n        persistentDbPath = fileManager->getCreatedFilePath("migration_test.db");\n    }\n};\n\nTEST_F(DatabaseMigrationTest, SchemaCreationAndValidation) {\n    DatabaseManager dbManager(persistentDbPath);\n    \n    // Create table\n    EXPECT_NO_THROW(dbManager.createTable());\n    \n    // Verify table creation by inserting and verifying data\n    FileData testData = createTestFileData();\n    \n    EXPECT_NO_THROW(dbManager.insertRecording(\n        testData.date, testData.time, testData.unixtime,\n        testData.talkgroupID, testData.talkgroupName, testData.radioID,\n        testData.duration, testData.filename, testData.filepath,\n        testData.transcription, testData.v2transcription\n    ));\n}\n\nTEST_F(DatabaseMigrationTest, DatabasePersistenceTest) {\n    // Create database and insert data\n    {\n        DatabaseManager dbManager(persistentDbPath);\n        dbManager.createTable();\n        \n        FileData testData = createTestFileData();\n        dbManager.insertRecording(\n            testData.date, testData.time, testData.unixtime,\n            testData.talkgroupID, testData.talkgroupName, testData.radioID,\n            testData.duration, testData.filename, testData.filepath,\n            testData.transcription, testData.v2transcription\n        );\n    }\n    \n    // Verify data persists after manager destruction\n    {\n        DatabaseManager dbManager2(persistentDbPath);\n        // Database should still exist and be accessible\n        EXPECT_NO_THROW(dbManager2.createTable());  // Should not fail on existing table\n    }\n}\n\n// =============================================================================\n// FILE MONITORING SIMULATION TESTS\n// =============================================================================\n\nclass FileMonitoringTest : public SDRTrunkTestFixture {\nprotected:\n    std::string monitorDir;\n    std::atomic<int> filesProcessed{0};\n    std::atomic<bool> stopMonitoring{false};\n    \n    void SetUp() override {\n        SDRTrunkTestFixture::SetUp();\n        monitorDir = fileManager->createTempDirectory("monitor_simulation");\n    }\n    \n    void simulateFileCreation(int fileCount, std::chrono::milliseconds interval) {\n        for (int i = 0; i < fileCount && !stopMonitoring.load(); ++i) {\n            std::string filename = TestDataGenerator::generateP25Filename(\n                2024, 1, 15, 14, 30, i, 52198 + (i % 5), 12345 + i\n            );\n            std::string filePath = monitorDir + "/" + filename;\n            \n            auto audioData = TestDataGenerator::generateMockMP3Data();\n            std::ofstream file(filePath, std::ios::binary);\n            file.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n            file.close();\n            \n            std::this_thread::sleep_for(interval);\n        }\n    }\n};\n\nTEST_F(FileMonitoringTest, ContinuousFileProcessingSimulation) {\n    const int fileCount = 20;\n    const auto creationInterval = std::chrono::milliseconds(100);\n    \n    // Start file creation in separate thread\n    std::future<void> fileCreator = std::async(std::launch::async, [this, fileCount, creationInterval]() {\n        simulateFileCreation(fileCount, creationInterval);\n    });\n    \n    // Monitor and process files\n    auto startTime = std::chrono::steady_clock::now();\n    const auto maxWaitTime = std::chrono::seconds(5);\n    \n    while (filesProcessed.load() < fileCount && \n           std::chrono::steady_clock::now() - startTime < maxWaitTime) {\n        \n        // Check for new MP3 files\n        for (const auto& entry : std::filesystem::directory_iterator(monitorDir)) {\n            if (entry.path().extension() == ".mp3") {\n                // Simulate file processing check\n                if (!isFileBeingWrittenTo(entry.path().string()) && \n                    !isFileLocked(entry.path().string())) {\n                    \n                    FileData data = processFile(entry.path(), monitorDir, "test-api-key");\n                    \n                    if (!data.filename.empty()) {\n                        filesProcessed.fetch_add(1);\n                        \n                        // Remove processed file to avoid reprocessing\n                        std::filesystem::remove(entry.path());\n                    }\n                }\n            }\n        }\n        \n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n    \n    stopMonitoring.store(true);\n    fileCreator.wait();\n    \n    EXPECT_EQ(filesProcessed.load(), fileCount)\n        << "Expected to process " << fileCount << " files, but processed " << filesProcessed.load();\n}\n\nTEST_F(FileMonitoringTest, FileMovementAndCleanupTest) {\n    // Create test files with and without .txt counterparts\n    std::vector<std::string> mp3Files = {\n        "20240115_143045_TG_52198_ID_12345.mp3",\n        "20240115_143046_TG_52198_ID_12346.mp3",  // This one will have .txt\n        "20240115_143047_TG_52198_ID_12347.mp3"\n    };\n    \n    for (const auto& filename : mp3Files) {\n        std::string filePath = monitorDir + "/" + filename;\n        auto audioData = TestDataGenerator::generateMockMP3Data();\n        std::ofstream file(filePath, std::ios::binary);\n        file.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n    }\n    \n    // Create .txt file for one MP3 (simulating completed processing)\n    std::string txtFile = monitorDir + "/20240115_143046_TG_52198_ID_12346.txt";\n    std::ofstream txt(txtFile);\n    txt << "Completed transcription marker";\n    txt.close();\n    \n    // Test the cleanup function\n    EXPECT_NO_THROW(find_and_move_mp3_without_txt(monitorDir));\n    \n    // Verify that file with .txt counterpart still exists\n    EXPECT_TRUE(std::filesystem::exists(monitorDir + "/20240115_143046_TG_52198_ID_12346.mp3"));\n    \n    // Files without .txt should be moved or processed (behavior depends on implementation)\n    // This test validates the function doesn't crash with various file combinations\n}\n\n// =============================================================================\n// CONCURRENCY AND THREAD SAFETY TESTS\n// =============================================================================\n\nclass ConcurrencyIntegrationTest : public SDRTrunkTestFixture {\nprotected:\n    std::unique_ptr<DatabaseManager> dbManager;\n    \n    void SetUp() override {\n        SDRTrunkTestFixture::SetUp();\n        dbManager = std::make_unique<DatabaseManager>(":memory:");\n        dbManager->createTable();\n    }\n};\n\nTEST_F(ConcurrencyIntegrationTest, ConcurrentFileProcessingAndStorage) {\n    const int threadCount = 4;\n    const int filesPerThread = 25;\n    \n    std::vector<std::future<int>> futures;\n    \n    for (int t = 0; t < threadCount; ++t) {\n        futures.push_back(std::async(std::launch::async, [this, t, filesPerThread]() {\n            int processed = 0;\n            \n            for (int i = 0; i < filesPerThread; ++i) {\n                // Create unique test file for this thread\n                std::string filename = TestDataGenerator::generateP25Filename(\n                    2024, 1, 15, 14, 30, (t * filesPerThread) + i,\n                    52198 + t, 12345 + (t * filesPerThread) + i\n                );\n                \n                std::string threadDir = fileManager->createTempDirectory(\n                    "thread_" + std::to_string(t) + "_" + std::to_string(i)\n                );\n                std::string filePath = threadDir + "/" + filename;\n                \n                auto audioData = TestDataGenerator::generateMockMP3Data();\n                std::ofstream file(filePath, std::ios::binary);\n                file.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n                file.close();\n                \n                // Process file\n                FileData data = processFile(\n                    std::filesystem::path(filePath),\n                    threadDir,\n                    "test-api-key"\n                );\n                \n                if (!data.filename.empty()) {\n                    // Note: In a real application, you would need proper synchronization\n                    // for database access or use connection pooling\n                    processed++;\n                }\n            }\n            \n            return processed;\n        }));\n    }\n    \n    // Wait for all threads to complete\n    int totalProcessed = 0;\n    for (auto& future : futures) {\n        totalProcessed += future.get();\n    }\n    \n    EXPECT_EQ(totalProcessed, threadCount * filesPerThread)\n        << "Expected to process " << (threadCount * filesPerThread) \n        << " files across " << threadCount << " threads";\n}\n\nTEST_F(ConcurrencyIntegrationTest, ConfigSingletonThreadSafety) {\n    const int threadCount = 10;\n    const int accessesPerThread = 1000;\n    \n    // Initialize config once\n    YAML::Node config = loadTestConfig();\n    auto& configSingleton = ConfigSingleton::getInstance();\n    configSingleton.initialize(config);\n    \n    std::vector<std::future<bool>> futures;\n    \n    for (int t = 0; t < threadCount; ++t) {\n        futures.push_back(std::async(std::launch::async, [&configSingleton, accessesPerThread]() {\n            for (int i = 0; i < accessesPerThread; ++i) {\n                // Multiple threads accessing config simultaneously\n                std::string apiKey = configSingleton.getOpenAIAPIKey();\n                int loopWait = configSingleton.getLoopWaitSeconds();\n                bool debug = configSingleton.isDebugMain();\n                \n                // Validate consistency\n                if (apiKey != "test-api-key-12345" || loopWait != 5) {\n                    return false;\n                }\n            }\n            return true;\n        }));\n    }\n    \n    // All threads should complete successfully with consistent data\n    for (auto& future : futures) {\n        EXPECT_TRUE(future.get()) << "Config access should be thread-safe and consistent";\n    }\n}\n\n// =============================================================================\n// ERROR HANDLING AND RECOVERY TESTS\n// =============================================================================\n\nclass ErrorHandlingIntegrationTest : public SDRTrunkTestFixture {};\n\nTEST_F(ErrorHandlingIntegrationTest, CorruptedFileHandling) {\n    std::string corruptedFile = fileManager->createTempDirectory("corrupted") + "/corrupted.mp3";\n    \n    // Create a file with invalid MP3 content\n    std::ofstream file(corruptedFile, std::ios::binary);\n    file << "This is not a valid MP3 file content";\n    file.close();\n    \n    // Processing should not crash\n    EXPECT_NO_THROW({\n        FileData data = processFile(\n            std::filesystem::path(corruptedFile),\n            fileManager->getCreatedFilePath("corrupted"),\n            "test-api-key"\n        );\n        \n        // Should handle gracefully (exact behavior depends on implementation)\n    });\n}\n\nTEST_F(ErrorHandlingIntegrationTest, InvalidFilenamePatterns) {\n    std::vector<std::string> invalidFilenames = {\n        "invalid_pattern.mp3",\n        "20240115_invalid_TG_52198_ID_12345.mp3",\n        "20240115_143045_TG_INVALID_ID_12345.mp3",\n        "20240115_143045_TG_52198_ID_INVALID.mp3",\n        ".mp3",  // Empty base name\n        "justtext.mp3"\n    };\n    \n    std::string testDir = fileManager->createTempDirectory("invalid_files");\n    \n    for (const auto& filename : invalidFilenames) {\n        std::string filePath = testDir + "/" + filename;\n        auto audioData = TestDataGenerator::generateMockMP3Data();\n        std::ofstream file(filePath, std::ios::binary);\n        file.write(reinterpret_cast<const char*>(audioData.data()), audioData.size());\n        file.close();\n        \n        // Should not crash on invalid filename patterns\n        EXPECT_NO_THROW({\n            FileData data = processFile(\n                std::filesystem::path(filePath),\n                testDir,\n                "test-api-key"\n            );\n            \n            // Invalid files should result in empty or default data\n            if (filename == "invalid_pattern.mp3" || filename == ".mp3" || filename == "justtext.mp3") {\n                EXPECT_TRUE(data.filename.empty() || data.talkgroupID == 0 || data.radioID == 0)\n                    << "Invalid filename should not produce valid data: " << filename;\n            }\n        });\n    }\n}\n\nTEST_F(ErrorHandlingIntegrationTest, MissingGlossaryFileHandling) {\n    // Create config with non-existent glossary files\n    YAML::Node config = loadTestConfig();\n    YAML::Node talkgroupFiles;\n    YAML::Node testTalkgroup;\n    YAML::Node glossary;\n    glossary.push_back("/nonexistent/path/glossary.json");\n    testTalkgroup["GLOSSARY"] = glossary;\n    talkgroupFiles["52198"] = testTalkgroup;\n    config["TALKGROUP_FILES"] = talkgroupFiles;\n    \n    auto& configSingleton = ConfigSingleton::getInstance();\n    \n    // Should initialize without crashing (may log errors)\n    EXPECT_NO_THROW(configSingleton.initialize(config));\n    \n    // Transcription generation should handle missing glossary gracefully\n    std::string mockTranscription = TestDataGenerator::generateOpenAIResponse(\n        "Test transcription with officer and unit"\n    );\n    \n    EXPECT_NO_THROW({\n        std::string result = generateV2Transcription(\n            mockTranscription, 52198, 12345, configSingleton.getTalkgroupFiles()\n        );\n        \n        // Should return something (even if glossary mappings failed)\n        EXPECT_FALSE(result.empty());\n    });\n}"